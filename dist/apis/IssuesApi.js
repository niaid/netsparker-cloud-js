/* tslint:disable */
/* eslint-disable */
/**
 * Invicti Enterprise API
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: v1
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
import * as runtime from '../runtime';
import { AllIssuesApiModelFromJSON, IssueApiResultFromJSON, IssueApiUpdateModelToJSON, IssueSummaryApiResultFromJSON, VulnerabilityContentApiModelFromJSON, } from '../models/index';
/**
 *
 */
export class IssuesApi extends runtime.BaseAPI {
    /**
     * Gets the list of addressed issues.
     */
    async issuesAddressedIssuesRaw(requestParameters, initOverrides) {
        const queryParameters = {};
        if (requestParameters.severity !== undefined) {
            queryParameters['severity'] = requestParameters.severity;
        }
        if (requestParameters.webSiteName !== undefined) {
            queryParameters['webSiteName'] = requestParameters.webSiteName;
        }
        if (requestParameters.websiteGroupName !== undefined) {
            queryParameters['websiteGroupName'] = requestParameters.websiteGroupName;
        }
        if (requestParameters.page !== undefined) {
            queryParameters['page'] = requestParameters.page;
        }
        if (requestParameters.pageSize !== undefined) {
            queryParameters['pageSize'] = requestParameters.pageSize;
        }
        const headerParameters = {};
        const response = await this.request({
            path: `/api/1.0/issues/addressedissues`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);
        return new runtime.JSONApiResponse(response, (jsonValue) => IssueApiResultFromJSON(jsonValue));
    }
    /**
     * Gets the list of addressed issues.
     */
    async issuesAddressedIssues(requestParameters = {}, initOverrides) {
        const response = await this.issuesAddressedIssuesRaw(requestParameters, initOverrides);
        return await response.value();
    }
    /**
     * Gets the list of all issues.
     */
    async issuesAllIssuesRaw(requestParameters, initOverrides) {
        const queryParameters = {};
        if (requestParameters.severity !== undefined) {
            queryParameters['severity'] = requestParameters.severity;
        }
        if (requestParameters.webSiteName !== undefined) {
            queryParameters['webSiteName'] = requestParameters.webSiteName;
        }
        if (requestParameters.websiteGroupName !== undefined) {
            queryParameters['websiteGroupName'] = requestParameters.websiteGroupName;
        }
        if (requestParameters.page !== undefined) {
            queryParameters['page'] = requestParameters.page;
        }
        if (requestParameters.pageSize !== undefined) {
            queryParameters['pageSize'] = requestParameters.pageSize;
        }
        if (requestParameters.sortType !== undefined) {
            queryParameters['sortType'] = requestParameters.sortType;
        }
        if (requestParameters.lastSeenDate !== undefined) {
            queryParameters['lastSeenDate'] = requestParameters.lastSeenDate;
        }
        if (requestParameters.rawDetails !== undefined) {
            queryParameters['rawDetails'] = requestParameters.rawDetails;
        }
        if (requestParameters.integration !== undefined) {
            queryParameters['integration'] = requestParameters.integration;
        }
        const headerParameters = {};
        const response = await this.request({
            path: `/api/1.0/issues/allissues`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);
        return new runtime.JSONApiResponse(response, (jsonValue) => IssueApiResultFromJSON(jsonValue));
    }
    /**
     * Gets the list of all issues.
     */
    async issuesAllIssues(requestParameters = {}, initOverrides) {
        const response = await this.issuesAllIssuesRaw(requestParameters, initOverrides);
        return await response.value();
    }
    /**
     * Gets issues by id. Returns with encoded(raw html) vulnerability template data by default.
     */
    async issuesGetRaw(requestParameters, initOverrides) {
        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id', 'Required parameter requestParameters.id was null or undefined when calling issuesGet.');
        }
        const queryParameters = {};
        const headerParameters = {};
        const response = await this.request({
            path: `/api/1.0/issues/get/{id}`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);
        return new runtime.JSONApiResponse(response, (jsonValue) => AllIssuesApiModelFromJSON(jsonValue));
    }
    /**
     * Gets issues by id. Returns with encoded(raw html) vulnerability template data by default.
     */
    async issuesGet(requestParameters, initOverrides) {
        const response = await this.issuesGetRaw(requestParameters, initOverrides);
        return await response.value();
    }
    /**
     * Gets vulnerability request/response content by id.
     */
    async issuesGetVulnerabilityContentRaw(requestParameters, initOverrides) {
        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id', 'Required parameter requestParameters.id was null or undefined when calling issuesGetVulnerabilityContent.');
        }
        const queryParameters = {};
        const headerParameters = {};
        const response = await this.request({
            path: `/api/1.0/issues/getvulnerabilitycontent/{id}`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);
        return new runtime.JSONApiResponse(response, (jsonValue) => VulnerabilityContentApiModelFromJSON(jsonValue));
    }
    /**
     * Gets vulnerability request/response content by id.
     */
    async issuesGetVulnerabilityContent(requestParameters, initOverrides) {
        const response = await this.issuesGetVulnerabilityContentRaw(requestParameters, initOverrides);
        return await response.value();
    }
    /**
     * Generates a report of issues in the CSV format.
     */
    async issuesReportRaw(requestParameters, initOverrides) {
        const queryParameters = {};
        if (requestParameters.csvSeparator !== undefined) {
            queryParameters['csvSeparator'] = requestParameters.csvSeparator;
        }
        if (requestParameters.severity !== undefined) {
            queryParameters['severity'] = requestParameters.severity;
        }
        if (requestParameters.websiteGroupName !== undefined) {
            queryParameters['websiteGroupName'] = requestParameters.websiteGroupName;
        }
        if (requestParameters.webSiteName !== undefined) {
            queryParameters['webSiteName'] = requestParameters.webSiteName;
        }
        if (requestParameters.startDate !== undefined) {
            queryParameters['startDate'] = requestParameters.startDate.toISOString();
        }
        if (requestParameters.endDate !== undefined) {
            queryParameters['endDate'] = requestParameters.endDate.toISOString();
        }
        const headerParameters = {};
        const response = await this.request({
            path: `/api/1.0/issues/report`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);
        return new runtime.VoidApiResponse(response);
    }
    /**
     * Generates a report of issues in the CSV format.
     */
    async issuesReport(requestParameters = {}, initOverrides) {
        await this.issuesReportRaw(requestParameters, initOverrides);
    }
    /**
     * Gets the summary of vulnerabilities
     */
    async issuesSummaryRaw(requestParameters, initOverrides) {
        if (requestParameters.targetUri === null || requestParameters.targetUri === undefined) {
            throw new runtime.RequiredError('targetUri', 'Required parameter requestParameters.targetUri was null or undefined when calling issuesSummary.');
        }
        if (requestParameters.websiteRoot === null || requestParameters.websiteRoot === undefined) {
            throw new runtime.RequiredError('websiteRoot', 'Required parameter requestParameters.websiteRoot was null or undefined when calling issuesSummary.');
        }
        const queryParameters = {};
        if (requestParameters.targetUri !== undefined) {
            queryParameters['targetUri'] = requestParameters.targetUri;
        }
        if (requestParameters.websiteRoot !== undefined) {
            queryParameters['websiteRoot'] = requestParameters.websiteRoot;
        }
        if (requestParameters.sinceDate !== undefined) {
            queryParameters['sinceDate'] = requestParameters.sinceDate;
        }
        if (requestParameters.scanTaskGroupId !== undefined) {
            queryParameters['scanTaskGroupId'] = requestParameters.scanTaskGroupId;
        }
        if (requestParameters.page !== undefined) {
            queryParameters['page'] = requestParameters.page;
        }
        if (requestParameters.pageSize !== undefined) {
            queryParameters['pageSize'] = requestParameters.pageSize;
        }
        const headerParameters = {};
        const response = await this.request({
            path: `/api/1.0/issues/summary`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);
        return new runtime.JSONApiResponse(response, (jsonValue) => IssueSummaryApiResultFromJSON(jsonValue));
    }
    /**
     * Gets the summary of vulnerabilities
     */
    async issuesSummary(requestParameters, initOverrides) {
        const response = await this.issuesSummaryRaw(requestParameters, initOverrides);
        return await response.value();
    }
    /**
     * Gets the list of to-do issues.
     */
    async issuesTodoRaw(requestParameters, initOverrides) {
        const queryParameters = {};
        if (requestParameters.severity !== undefined) {
            queryParameters['severity'] = requestParameters.severity;
        }
        if (requestParameters.webSiteName !== undefined) {
            queryParameters['webSiteName'] = requestParameters.webSiteName;
        }
        if (requestParameters.websiteGroupName !== undefined) {
            queryParameters['websiteGroupName'] = requestParameters.websiteGroupName;
        }
        if (requestParameters.page !== undefined) {
            queryParameters['page'] = requestParameters.page;
        }
        if (requestParameters.pageSize !== undefined) {
            queryParameters['pageSize'] = requestParameters.pageSize;
        }
        const headerParameters = {};
        const response = await this.request({
            path: `/api/1.0/issues/todo`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);
        return new runtime.JSONApiResponse(response, (jsonValue) => IssueApiResultFromJSON(jsonValue));
    }
    /**
     * Gets the list of to-do issues.
     */
    async issuesTodo(requestParameters = {}, initOverrides) {
        const response = await this.issuesTodoRaw(requestParameters, initOverrides);
        return await response.value();
    }
    /**
     * Updates an existing issue.
     */
    async issuesUpdateRaw(requestParameters, initOverrides) {
        if (requestParameters.model === null || requestParameters.model === undefined) {
            throw new runtime.RequiredError('model', 'Required parameter requestParameters.model was null or undefined when calling issuesUpdate.');
        }
        const queryParameters = {};
        const headerParameters = {};
        headerParameters['Content-Type'] = 'application/json';
        const response = await this.request({
            path: `/api/1.0/issues/update`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: IssueApiUpdateModelToJSON(requestParameters.model),
        }, initOverrides);
        return new runtime.VoidApiResponse(response);
    }
    /**
     * Updates an existing issue.
     */
    async issuesUpdate(requestParameters, initOverrides) {
        await this.issuesUpdateRaw(requestParameters, initOverrides);
    }
    /**
     * Gets the list of retest issues.
     */
    async issuesWaitingForRetestRaw(requestParameters, initOverrides) {
        const queryParameters = {};
        if (requestParameters.severity !== undefined) {
            queryParameters['severity'] = requestParameters.severity;
        }
        if (requestParameters.webSiteName !== undefined) {
            queryParameters['webSiteName'] = requestParameters.webSiteName;
        }
        if (requestParameters.websiteGroupName !== undefined) {
            queryParameters['websiteGroupName'] = requestParameters.websiteGroupName;
        }
        if (requestParameters.page !== undefined) {
            queryParameters['page'] = requestParameters.page;
        }
        if (requestParameters.pageSize !== undefined) {
            queryParameters['pageSize'] = requestParameters.pageSize;
        }
        const headerParameters = {};
        const response = await this.request({
            path: `/api/1.0/issues/waitingforretest`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);
        return new runtime.JSONApiResponse(response, (jsonValue) => IssueApiResultFromJSON(jsonValue));
    }
    /**
     * Gets the list of retest issues.
     */
    async issuesWaitingForRetest(requestParameters = {}, initOverrides) {
        const response = await this.issuesWaitingForRetestRaw(requestParameters, initOverrides);
        return await response.value();
    }
}
/**
 * @export
 */
export const IssuesAddressedIssuesSeverityEnum = {
    BestPractice: 'BestPractice',
    Information: 'Information',
    Low: 'Low',
    Medium: 'Medium',
    High: 'High',
    Critical: 'Critical'
};
/**
 * @export
 */
export const IssuesAllIssuesSeverityEnum = {
    BestPractice: 'BestPractice',
    Information: 'Information',
    Low: 'Low',
    Medium: 'Medium',
    High: 'High',
    Critical: 'Critical'
};
/**
 * @export
 */
export const IssuesAllIssuesSortTypeEnum = {
    Ascending: 'Ascending',
    Descending: 'Descending'
};
/**
 * @export
 */
export const IssuesAllIssuesIntegrationEnum = {
    Jira: 'Jira',
    GitHub: 'GitHub',
    Tfs: 'TFS',
    FogBugz: 'FogBugz',
    ServiceNow: 'ServiceNow',
    Slack: 'Slack',
    GitLab: 'GitLab',
    Bitbucket: 'Bitbucket',
    Unfuddle: 'Unfuddle',
    Zapier: 'Zapier',
    AzureDevOps: 'AzureDevOps',
    Redmine: 'Redmine',
    Bugzilla: 'Bugzilla',
    Kafka: 'Kafka',
    PagerDuty: 'PagerDuty',
    MicrosoftTeams: 'MicrosoftTeams',
    Clubhouse: 'Clubhouse',
    Trello: 'Trello',
    Asana: 'Asana',
    Webhook: 'Webhook',
    Kenna: 'Kenna',
    Freshservice: 'Freshservice',
    YouTrack: 'YouTrack',
    NetsparkerEnterprise: 'NetsparkerEnterprise',
    Splunk: 'Splunk',
    Mattermost: 'Mattermost',
    Hashicorp: 'Hashicorp',
    PivotalTracker: 'PivotalTracker',
    CyberArk: 'CyberArk',
    DefectDojo: 'DefectDojo',
    JazzTeam: 'JazzTeam',
    AzureKeyVault: 'AzureKeyVault',
    ServiceNowVrm: 'ServiceNowVRM'
};
/**
 * @export
 */
export const IssuesReportCsvSeparatorEnum = {
    Comma: 'Comma',
    Semicolon: 'Semicolon',
    Pipe: 'Pipe',
    Tab: 'Tab'
};
/**
 * @export
 */
export const IssuesReportSeverityEnum = {
    BestPractice: 'BestPractice',
    Information: 'Information',
    Low: 'Low',
    Medium: 'Medium',
    High: 'High',
    Critical: 'Critical'
};
/**
 * @export
 */
export const IssuesTodoSeverityEnum = {
    BestPractice: 'BestPractice',
    Information: 'Information',
    Low: 'Low',
    Medium: 'Medium',
    High: 'High',
    Critical: 'Critical'
};
/**
 * @export
 */
export const IssuesWaitingForRetestSeverityEnum = {
    BestPractice: 'BestPractice',
    Information: 'Information',
    Low: 'Low',
    Medium: 'Medium',
    High: 'High',
    Critical: 'Critical'
};
//# sourceMappingURL=IssuesApi.js.map