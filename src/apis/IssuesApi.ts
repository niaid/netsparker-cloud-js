/* tslint:disable */
/* eslint-disable */
/**
 * Invicti Enterprise API
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: v1
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import * as runtime from '../runtime';
import type {
  AllIssuesApiModel,
  IssueApiResult,
  IssueApiUpdateModel,
  IssueSummaryApiResult,
  VulnerabilityContentApiModel,
} from '../models/index';
import {
    AllIssuesApiModelFromJSON,
    AllIssuesApiModelToJSON,
    IssueApiResultFromJSON,
    IssueApiResultToJSON,
    IssueApiUpdateModelFromJSON,
    IssueApiUpdateModelToJSON,
    IssueSummaryApiResultFromJSON,
    IssueSummaryApiResultToJSON,
    VulnerabilityContentApiModelFromJSON,
    VulnerabilityContentApiModelToJSON,
} from '../models/index';

export interface IssuesAddressedIssuesRequest {
    severity?: IssuesAddressedIssuesSeverityEnum;
    webSiteName?: string;
    websiteGroupName?: string;
    page?: number;
    pageSize?: number;
}

export interface IssuesAllIssuesRequest {
    severity?: IssuesAllIssuesSeverityEnum;
    webSiteName?: string;
    websiteGroupName?: string;
    page?: number;
    pageSize?: number;
    sortType?: IssuesAllIssuesSortTypeEnum;
    lastSeenDate?: string;
    rawDetails?: boolean;
    integration?: IssuesAllIssuesIntegrationEnum;
}

export interface IssuesGetRequest {
    id: string;
}

export interface IssuesGetVulnerabilityContentRequest {
    id: string;
}

export interface IssuesReportRequest {
    csvSeparator?: IssuesReportCsvSeparatorEnum;
    severity?: IssuesReportSeverityEnum;
    websiteGroupName?: string;
    webSiteName?: string;
    startDate?: Date;
    endDate?: Date;
}

export interface IssuesSummaryRequest {
    targetUri: string;
    websiteRoot: string;
    sinceDate?: string;
    scanTaskGroupId?: string;
    page?: number;
    pageSize?: number;
}

export interface IssuesTodoRequest {
    severity?: IssuesTodoSeverityEnum;
    webSiteName?: string;
    websiteGroupName?: string;
    page?: number;
    pageSize?: number;
}

export interface IssuesUpdateRequest {
    model: IssueApiUpdateModel;
}

export interface IssuesWaitingForRetestRequest {
    severity?: IssuesWaitingForRetestSeverityEnum;
    webSiteName?: string;
    websiteGroupName?: string;
    page?: number;
    pageSize?: number;
}

/**
 * 
 */
export class IssuesApi extends runtime.BaseAPI {

    /**
     * Gets the list of addressed issues.
     */
    async issuesAddressedIssuesRaw(requestParameters: IssuesAddressedIssuesRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<IssueApiResult>> {
        const queryParameters: any = {};

        if (requestParameters.severity !== undefined) {
            queryParameters['severity'] = requestParameters.severity;
        }

        if (requestParameters.webSiteName !== undefined) {
            queryParameters['webSiteName'] = requestParameters.webSiteName;
        }

        if (requestParameters.websiteGroupName !== undefined) {
            queryParameters['websiteGroupName'] = requestParameters.websiteGroupName;
        }

        if (requestParameters.page !== undefined) {
            queryParameters['page'] = requestParameters.page;
        }

        if (requestParameters.pageSize !== undefined) {
            queryParameters['pageSize'] = requestParameters.pageSize;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/api/1.0/issues/addressedissues`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => IssueApiResultFromJSON(jsonValue));
    }

    /**
     * Gets the list of addressed issues.
     */
    async issuesAddressedIssues(requestParameters: IssuesAddressedIssuesRequest = {}, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<IssueApiResult> {
        const response = await this.issuesAddressedIssuesRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Gets the list of all issues.
     */
    async issuesAllIssuesRaw(requestParameters: IssuesAllIssuesRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<IssueApiResult>> {
        const queryParameters: any = {};

        if (requestParameters.severity !== undefined) {
            queryParameters['severity'] = requestParameters.severity;
        }

        if (requestParameters.webSiteName !== undefined) {
            queryParameters['webSiteName'] = requestParameters.webSiteName;
        }

        if (requestParameters.websiteGroupName !== undefined) {
            queryParameters['websiteGroupName'] = requestParameters.websiteGroupName;
        }

        if (requestParameters.page !== undefined) {
            queryParameters['page'] = requestParameters.page;
        }

        if (requestParameters.pageSize !== undefined) {
            queryParameters['pageSize'] = requestParameters.pageSize;
        }

        if (requestParameters.sortType !== undefined) {
            queryParameters['sortType'] = requestParameters.sortType;
        }

        if (requestParameters.lastSeenDate !== undefined) {
            queryParameters['lastSeenDate'] = requestParameters.lastSeenDate;
        }

        if (requestParameters.rawDetails !== undefined) {
            queryParameters['rawDetails'] = requestParameters.rawDetails;
        }

        if (requestParameters.integration !== undefined) {
            queryParameters['integration'] = requestParameters.integration;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/api/1.0/issues/allissues`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => IssueApiResultFromJSON(jsonValue));
    }

    /**
     * Gets the list of all issues.
     */
    async issuesAllIssues(requestParameters: IssuesAllIssuesRequest = {}, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<IssueApiResult> {
        const response = await this.issuesAllIssuesRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Gets issues by id. Returns with encoded(raw html) vulnerability template data by default.
     */
    async issuesGetRaw(requestParameters: IssuesGetRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<AllIssuesApiModel>> {
        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling issuesGet.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/api/1.0/issues/get/{id}`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => AllIssuesApiModelFromJSON(jsonValue));
    }

    /**
     * Gets issues by id. Returns with encoded(raw html) vulnerability template data by default.
     */
    async issuesGet(requestParameters: IssuesGetRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<AllIssuesApiModel> {
        const response = await this.issuesGetRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Gets vulnerability request/response content by id.
     */
    async issuesGetVulnerabilityContentRaw(requestParameters: IssuesGetVulnerabilityContentRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<VulnerabilityContentApiModel>> {
        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling issuesGetVulnerabilityContent.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/api/1.0/issues/getvulnerabilitycontent/{id}`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => VulnerabilityContentApiModelFromJSON(jsonValue));
    }

    /**
     * Gets vulnerability request/response content by id.
     */
    async issuesGetVulnerabilityContent(requestParameters: IssuesGetVulnerabilityContentRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<VulnerabilityContentApiModel> {
        const response = await this.issuesGetVulnerabilityContentRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Generates a report of issues in the CSV format.
     */
    async issuesReportRaw(requestParameters: IssuesReportRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        const queryParameters: any = {};

        if (requestParameters.csvSeparator !== undefined) {
            queryParameters['csvSeparator'] = requestParameters.csvSeparator;
        }

        if (requestParameters.severity !== undefined) {
            queryParameters['severity'] = requestParameters.severity;
        }

        if (requestParameters.websiteGroupName !== undefined) {
            queryParameters['websiteGroupName'] = requestParameters.websiteGroupName;
        }

        if (requestParameters.webSiteName !== undefined) {
            queryParameters['webSiteName'] = requestParameters.webSiteName;
        }

        if (requestParameters.startDate !== undefined) {
            queryParameters['startDate'] = (requestParameters.startDate as any).toISOString();
        }

        if (requestParameters.endDate !== undefined) {
            queryParameters['endDate'] = (requestParameters.endDate as any).toISOString();
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/api/1.0/issues/report`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Generates a report of issues in the CSV format.
     */
    async issuesReport(requestParameters: IssuesReportRequest = {}, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.issuesReportRaw(requestParameters, initOverrides);
    }

    /**
     * Gets the summary of vulnerabilities
     */
    async issuesSummaryRaw(requestParameters: IssuesSummaryRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<IssueSummaryApiResult>> {
        if (requestParameters.targetUri === null || requestParameters.targetUri === undefined) {
            throw new runtime.RequiredError('targetUri','Required parameter requestParameters.targetUri was null or undefined when calling issuesSummary.');
        }

        if (requestParameters.websiteRoot === null || requestParameters.websiteRoot === undefined) {
            throw new runtime.RequiredError('websiteRoot','Required parameter requestParameters.websiteRoot was null or undefined when calling issuesSummary.');
        }

        const queryParameters: any = {};

        if (requestParameters.targetUri !== undefined) {
            queryParameters['targetUri'] = requestParameters.targetUri;
        }

        if (requestParameters.websiteRoot !== undefined) {
            queryParameters['websiteRoot'] = requestParameters.websiteRoot;
        }

        if (requestParameters.sinceDate !== undefined) {
            queryParameters['sinceDate'] = requestParameters.sinceDate;
        }

        if (requestParameters.scanTaskGroupId !== undefined) {
            queryParameters['scanTaskGroupId'] = requestParameters.scanTaskGroupId;
        }

        if (requestParameters.page !== undefined) {
            queryParameters['page'] = requestParameters.page;
        }

        if (requestParameters.pageSize !== undefined) {
            queryParameters['pageSize'] = requestParameters.pageSize;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/api/1.0/issues/summary`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => IssueSummaryApiResultFromJSON(jsonValue));
    }

    /**
     * Gets the summary of vulnerabilities
     */
    async issuesSummary(requestParameters: IssuesSummaryRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<IssueSummaryApiResult> {
        const response = await this.issuesSummaryRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Gets the list of to-do issues.
     */
    async issuesTodoRaw(requestParameters: IssuesTodoRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<IssueApiResult>> {
        const queryParameters: any = {};

        if (requestParameters.severity !== undefined) {
            queryParameters['severity'] = requestParameters.severity;
        }

        if (requestParameters.webSiteName !== undefined) {
            queryParameters['webSiteName'] = requestParameters.webSiteName;
        }

        if (requestParameters.websiteGroupName !== undefined) {
            queryParameters['websiteGroupName'] = requestParameters.websiteGroupName;
        }

        if (requestParameters.page !== undefined) {
            queryParameters['page'] = requestParameters.page;
        }

        if (requestParameters.pageSize !== undefined) {
            queryParameters['pageSize'] = requestParameters.pageSize;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/api/1.0/issues/todo`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => IssueApiResultFromJSON(jsonValue));
    }

    /**
     * Gets the list of to-do issues.
     */
    async issuesTodo(requestParameters: IssuesTodoRequest = {}, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<IssueApiResult> {
        const response = await this.issuesTodoRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Updates an existing issue.
     */
    async issuesUpdateRaw(requestParameters: IssuesUpdateRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.model === null || requestParameters.model === undefined) {
            throw new runtime.RequiredError('model','Required parameter requestParameters.model was null or undefined when calling issuesUpdate.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/api/1.0/issues/update`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: IssueApiUpdateModelToJSON(requestParameters.model),
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Updates an existing issue.
     */
    async issuesUpdate(requestParameters: IssuesUpdateRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.issuesUpdateRaw(requestParameters, initOverrides);
    }

    /**
     * Gets the list of retest issues.
     */
    async issuesWaitingForRetestRaw(requestParameters: IssuesWaitingForRetestRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<IssueApiResult>> {
        const queryParameters: any = {};

        if (requestParameters.severity !== undefined) {
            queryParameters['severity'] = requestParameters.severity;
        }

        if (requestParameters.webSiteName !== undefined) {
            queryParameters['webSiteName'] = requestParameters.webSiteName;
        }

        if (requestParameters.websiteGroupName !== undefined) {
            queryParameters['websiteGroupName'] = requestParameters.websiteGroupName;
        }

        if (requestParameters.page !== undefined) {
            queryParameters['page'] = requestParameters.page;
        }

        if (requestParameters.pageSize !== undefined) {
            queryParameters['pageSize'] = requestParameters.pageSize;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/api/1.0/issues/waitingforretest`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => IssueApiResultFromJSON(jsonValue));
    }

    /**
     * Gets the list of retest issues.
     */
    async issuesWaitingForRetest(requestParameters: IssuesWaitingForRetestRequest = {}, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<IssueApiResult> {
        const response = await this.issuesWaitingForRetestRaw(requestParameters, initOverrides);
        return await response.value();
    }

}

/**
 * @export
 */
export const IssuesAddressedIssuesSeverityEnum = {
    BestPractice: 'BestPractice',
    Information: 'Information',
    Low: 'Low',
    Medium: 'Medium',
    High: 'High',
    Critical: 'Critical'
} as const;
export type IssuesAddressedIssuesSeverityEnum = typeof IssuesAddressedIssuesSeverityEnum[keyof typeof IssuesAddressedIssuesSeverityEnum];
/**
 * @export
 */
export const IssuesAllIssuesSeverityEnum = {
    BestPractice: 'BestPractice',
    Information: 'Information',
    Low: 'Low',
    Medium: 'Medium',
    High: 'High',
    Critical: 'Critical'
} as const;
export type IssuesAllIssuesSeverityEnum = typeof IssuesAllIssuesSeverityEnum[keyof typeof IssuesAllIssuesSeverityEnum];
/**
 * @export
 */
export const IssuesAllIssuesSortTypeEnum = {
    Ascending: 'Ascending',
    Descending: 'Descending'
} as const;
export type IssuesAllIssuesSortTypeEnum = typeof IssuesAllIssuesSortTypeEnum[keyof typeof IssuesAllIssuesSortTypeEnum];
/**
 * @export
 */
export const IssuesAllIssuesIntegrationEnum = {
    Jira: 'Jira',
    GitHub: 'GitHub',
    Tfs: 'TFS',
    FogBugz: 'FogBugz',
    ServiceNow: 'ServiceNow',
    Slack: 'Slack',
    GitLab: 'GitLab',
    Bitbucket: 'Bitbucket',
    Unfuddle: 'Unfuddle',
    Zapier: 'Zapier',
    AzureDevOps: 'AzureDevOps',
    Redmine: 'Redmine',
    Bugzilla: 'Bugzilla',
    Kafka: 'Kafka',
    PagerDuty: 'PagerDuty',
    MicrosoftTeams: 'MicrosoftTeams',
    Clubhouse: 'Clubhouse',
    Trello: 'Trello',
    Asana: 'Asana',
    Webhook: 'Webhook',
    Kenna: 'Kenna',
    Freshservice: 'Freshservice',
    YouTrack: 'YouTrack',
    NetsparkerEnterprise: 'NetsparkerEnterprise',
    Splunk: 'Splunk',
    Mattermost: 'Mattermost',
    Hashicorp: 'Hashicorp',
    PivotalTracker: 'PivotalTracker',
    CyberArk: 'CyberArk',
    DefectDojo: 'DefectDojo',
    JazzTeam: 'JazzTeam',
    AzureKeyVault: 'AzureKeyVault',
    ServiceNowVrm: 'ServiceNowVRM'
} as const;
export type IssuesAllIssuesIntegrationEnum = typeof IssuesAllIssuesIntegrationEnum[keyof typeof IssuesAllIssuesIntegrationEnum];
/**
 * @export
 */
export const IssuesReportCsvSeparatorEnum = {
    Comma: 'Comma',
    Semicolon: 'Semicolon',
    Pipe: 'Pipe',
    Tab: 'Tab'
} as const;
export type IssuesReportCsvSeparatorEnum = typeof IssuesReportCsvSeparatorEnum[keyof typeof IssuesReportCsvSeparatorEnum];
/**
 * @export
 */
export const IssuesReportSeverityEnum = {
    BestPractice: 'BestPractice',
    Information: 'Information',
    Low: 'Low',
    Medium: 'Medium',
    High: 'High',
    Critical: 'Critical'
} as const;
export type IssuesReportSeverityEnum = typeof IssuesReportSeverityEnum[keyof typeof IssuesReportSeverityEnum];
/**
 * @export
 */
export const IssuesTodoSeverityEnum = {
    BestPractice: 'BestPractice',
    Information: 'Information',
    Low: 'Low',
    Medium: 'Medium',
    High: 'High',
    Critical: 'Critical'
} as const;
export type IssuesTodoSeverityEnum = typeof IssuesTodoSeverityEnum[keyof typeof IssuesTodoSeverityEnum];
/**
 * @export
 */
export const IssuesWaitingForRetestSeverityEnum = {
    BestPractice: 'BestPractice',
    Information: 'Information',
    Low: 'Low',
    Medium: 'Medium',
    High: 'High',
    Critical: 'Critical'
} as const;
export type IssuesWaitingForRetestSeverityEnum = typeof IssuesWaitingForRetestSeverityEnum[keyof typeof IssuesWaitingForRetestSeverityEnum];
